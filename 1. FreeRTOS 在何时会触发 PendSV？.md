### 1. FreeRTOS 在何时会触发 PendSV？

在实际的 FreeRTOS 运行过程中，主要有以下三种场景会调用上述机制去触发 PendSV：

- **场景一：时间片轮转 (SysTick 中断)** 每次操作系统的“滴答”定时器（SysTick）中断发生时，FreeRTOS 会检查是否有优先级更高或同等优先级的任务就绪。如果有，SysTick 的中断服务函数（`xPortSysTickHandler`）内部就会将 PendSV 置位。
- **场景二：任务主动让出 CPU (Task Yield)** 当一个任务调用 `taskYIELD()` 或者调用了可能导致阻塞的 API（如 `vTaskDelay`, `xQueueReceive` 等且条件未满足时），任务会在代码中直接置位 PendSV 寄存器，要求立刻切换任务。
- **场景三：中断中唤醒了更高优先级任务 (Yield from ISR)** 在外部硬件中断（如串口接收中断）的服务函数中，如果我们释放了一个信号量，唤醒了一个优先级极高的任务。中断服务函数在退出前，会调用 `portYIELD_FROM_ISR()`，这同样会置位 PendSV。

------

### 2. 核心设计哲学：为什么要用 PendSV？

你可能会问：*为什么不直接在 SysTick 中断或者其他普通中断里直接做上下文切换，非要多此一举去触发一个 PendSV 呢？*

这是 FreeRTOS 最精妙的设计之一，核心原因是为了**保护系统的实时性和避免硬件故障（Usage Fault）**：

1. **设置最低优先级：** 在 FreeRTOS 初始化时，它会将 PendSV 的中断优先级配置为**最低**。
2. **延迟执行上下文切换：** 当 SysTick 或其他硬件中断（如 UART、SPI 中断）发生时，由于它们的优先级都比 PendSV 高，即使在这些中断内部触发了 PendSV（写了 ICSR 寄存器），**PendSV 也不会立刻执行**。
3. **等待所有中断处理完毕：** CPU 会先处理完所有高优先级的硬件中断，等所有中断都退出，系统准备回到线程模式时，才会去响应一直“悬挂（Pending）”在那里的 PendSV，并在 PendSV 的 Handler 中执行真正的上下文切换（保存当前任务的 CPU 寄存器，恢复下一个任务的 CPU 寄存器）。

**如果没有这个机制：** 如果在 SysTick 中直接切换上下文，假设系统正在处理一个串口中断（优先级高于普通任务），此时 SysTick 来了，强行把上下文切换到了另一个任务，那么原本串口中断的处理过程就被硬生生截断了。在 Cortex-M 中，这种在 ISR 中强行返回到另一个线程模式的操作，会直接引发硬件异常（Usage Fault/Hard Fault），导致系统崩溃。



### 第一部分：是先开启任务调度，再配置 SysTick 和 PendSV 吗？

**答案是：是的。准确地说，SysTick 和 PendSV 的配置是包含在 `vTaskStartScheduler()` 这个启动函数内部的“最后准备阶段”。**

当你在 `main()` 函数中调用 `vTaskStartScheduler()` 时，FreeRTOS 的内部执行时间线是这样的：

1. **创建系统级任务：** FreeRTOS 首先会自动创建一个“空闲任务（Idle Task）”，如果你开启了软件定时器，还会创建一个“定时器任务（Timer Task）”。
2. **进入移植层启动函数：** 接着，它会调用一个与硬件架构强相关的函数：`xPortStartScheduler()`。
3. **配置 PendSV 和 SysTick 优先级：** 在 `xPortStartScheduler()` 内部，FreeRTOS 会直接去写 Cortex-M 的系统控制寄存器，**将 PendSV 和 SysTick 的中断优先级设置为最低（通常是 0xFF）**。
4. **配置并启动 SysTick 定时器：** FreeRTOS 会根据你配置的 CPU 频率和系统节拍率（`configTICK_RATE_HZ`），计算出 SysTick 的重装载值，并启动硬件 SysTick 定时器。从这一刻起，系统的“心跳”就开始了。
5. **触发 SVC：** 一切准备就绪后，它调用底层的汇编函数 `prvStartFirstTask()`。在这个函数里，系统发出了那句致命的指令：`svc 0`。

**总结：** 调度器启动是一个过程。在这个过程中，FreeRTOS 帮你在底层默默配好了 SysTick 和 PendSV，然后用 SVC 踢出了“第一脚”，让系统从裸机模式正式跃迁到了 RTOS 模式。