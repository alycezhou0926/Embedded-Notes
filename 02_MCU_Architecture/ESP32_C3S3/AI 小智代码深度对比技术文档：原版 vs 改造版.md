# AI 小智代码深度对比技术文档：原版 vs 改造版

## 1. 任务调度与优先级对比 (`App_Audio.c` & `App_Communication.c`)

在嵌入式系统中，优先级决定了任务的实时性。改造版为了适配 PCM 裸流的高带宽需求，对任务优先级和部署进行了调整。

| **功能任务**     | **原版 (xiaozhi.me)** | **改造版 (本地服务器)** | **细节差异分析**                                             |
| ---------------- | --------------------- | ----------------------- | ------------------------------------------------------------ |
| **音频编码任务** | 优先级 **6**          | 优先级 **10** (核心 1)  | **改造：** 优先级大幅提升。虽然改造版不执行编码逻辑，但它负责将 PCM 数据搬运至网络层，提升优先级确保了音频流不因其他任务抢占而断流。 |
| **音频解码任务** | 优先级 **6**          | 优先级 **10** (核心 1)  | **改造：** 优先级从 6 升至 10。确保服务器传回的 PCM 裸流能即时写入 I2S 驱动，防止播放卡顿。 |
| **音频上传任务** | 优先级 **6**          | 优先级 **8**            | **改造：** 网络发送任务的优先级也进行了提升，确保数据包发送的间隔更加均匀。 |
| **SR 识别任务**  | 栈大小 8KB            | 栈大小 **12KB**         | **改造：** 调大了栈深度，防止在复杂的本地局域网环境下处理大量裸流数据时发生栈溢出。 |

------

## 2. 环形缓冲区 (RingBuffer) 大小对比 (`App_Application.c`)

缓冲区的大小直接影响系统处理抖动的能力。由于 PCM 数据量远大于 Opus 压缩数据，改造版对缓冲区容量做了扩容。

| **缓冲区名称**        | **原版大小** | **改造版大小** | **差异说明**                                                 |
| --------------------- | ------------ | -------------- | ------------------------------------------------------------ |
| `es8311_to_sr_buffer` | 48 KB        | **64 KB**      | **扩容：** 为语音识别预留更大的原始采样缓冲。                |
| `sr_to_encoder_buff`  | 48 KB        | **64 KB**      | **扩容：** 增加从识别到传输层的缓冲。                        |
| `encoder_to_ws_buff`  | 16 KB        | **32 KB**      | **倍增：** PCM 裸流数据量大，需要更深的队列防止 WebSocket 发送拥塞时丢包。 |
| `ws_to_decoder_buff`  | 16 KB        | **32 KB**      | **倍增：** 确保下行音频流有足够空间缓存，避免网络波动导致播放断续。 |

------

## 3. 音频处理逻辑逐行对比 (`App_Audio.c`)

### 3.1 编码逻辑（上行）

- 原版： ```c

  // 经历编码过程

  if (Inf_Encoder_Process(&in_frame, &out_frame) == ESP_AUDIO_ERR_OK) {

  xRingbufferSend(encoder_to_ws_buff, raw_data, out_frame.encoded_bytes, 0);

  }

- 改造版： ```c

  // 直接透传，注销了编码调用

  // Inf_Encoder_Process(&in_frame, &out_frame);

  xRingbufferSend(encoder_to_ws_buff, pcm_data, pcm_size, 0);

  ```
  **【实现功能】**：完全跳过 Opus 编码算法，降低 CPU 占用率，直接发送 16bit PCM 裸流给服务器。
  ```

### 3.2 解码逻辑（下行）

- **原版：** 使用 `while (raw.len > 0)` 配合 `Inf_Decoder_Process` 进行循环拆包解码。

- 改造版： ```c

  if (1) { // 强制进入直通模式

  Inf_ES8311_Write(raw.buffer, raw.len);

  raw.len = 0;

  }

  ```
  **【实现功能】**：移除解码器，服务器发来的数据被视为已就绪的 PCM，直接写入音频芯片播放。
  ```

------

## 4. 通信协议细节对比 (`App_Communication.c`)

### 4.1 Hello 握手数据包

改造版在 `App_Communication_SendHello` 函数中修改了 JSON 字段：

- **修改点：** `format` 字段由 `"opus"` 更改为 `"pcm"`。
- **功能：** 这是与私有服务器对接的关键。如果保持 "opus"，服务器会尝试用解压算法处理 PCM 数据，导致产生巨大的噪音。

### 4.2 增强的流控与防干扰

改造版在 `App_Communication_UploadAudioTaskFunc` 中加入了一个原版没有的判断：

C

```
if (!App_Communication_IsConnected() || communicationStatus != LISTENING) 
{
    if (datas) vRingbufferReturnItem(encoder_to_ws_buff, datas);
    vTaskDelay(10); 
    continue; 
}
```

**【对比细节】**：

- **原版：** 仅判断 `communicationStatus == LISTENING`，如果没有连接，数据可能会在缓冲区积压。
- **改造版：** 增加了连接状态强校验。如果网络断开，立即丢弃并回收当前音频帧内存，防止内存泄漏。

------

## 5. 新增功能：服务器防干扰锁 (Ping-Wait)

这是改造版最显著的功能新增。在 `App_Communication_WebsocketReceiveHandle` 中：

- **新增逻辑：** 当收到 `type == "ping"` 的消息时，执行 `communicationStatus = SPEAKING;`。
- **实现逻辑：** * 在原版中，`SPEAKING` 状态仅由 `tts start` 触发。
  - 在改造版中，利用服务器发送的 `ping`（心跳或思考占位符）提前锁定状态。
- **功能：** **“AI 思考保护”**。当 AI 还在组织语言阶段，设备就进入“说话中”状态。这会触发 VAD 自动抑制，防止用户此时的背景音或“啊、嗯”等语气词被当作新的指令发给服务器，打断当前的思考过程。

------

## 6. 总结建议

改造版通过**提高优先级**（从 6 升至 10）和**扩容缓冲区**（平均增加 50%-100%），解决了 PCM 裸流带来的高吞吐量压力。同时，通过**简化编解码链路**和**新增 Ping 状态锁**，使其更适合在局域网内与高响应速度的私有大模型后端进行实时交互。