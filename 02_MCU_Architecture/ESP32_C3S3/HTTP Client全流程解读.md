# HTTP Client全流程解读

### 1. 开场白

**这部戏的名字叫：《特工 007 的服务器潜入计划》。**

这段代码讲述了一个全副武装的数字特工（HTTP Client），如何接受你的委托，跨越网络大海，潜入远程服务器基地，不仅要通过安检（SSL握手），还要根据清单（Header）准备刚好够用的背包（内存申请），把情报（Data）一点点搬回来，最后亲手交给你（回调函数）。

------

### 2. 剧本拆解

我们将全剧分为三幕。请各位演员各就各位，Action！

#### 第一幕：特工岗前培训（初始化与配置）

这一幕发生在任务开始前，我们在基地里给特工分配装备。

| **代码片段 / 函数**             | **现实世界的比喻与含义**                                     |
| ------------------------------- | ------------------------------------------------------------ |
| `Dri_HttpClient_Init(...)`      | **比喻动作：签署任务合同** 这里不仅告诉特工要去哪里（`url`），还规定了交通方式（`HTTP_TRANSPORT_OVER_SSL`，即坐装甲车去，保证安全），以及如果不说话时的缓冲时间。 |
| `Dri_HttpClient_SetHeader(...)` | **比喻道具：特工的证件和暗号** 有时候服务器门口有保安，特工需要出示特定的 Header（如 Token 或 Content-Type）才能进入。 |
| `Dri_HttpClient_SetBody(...)`   | **比喻道具：特工携带的公文包** 如果是 POST 请求，特工不仅是去取东西，还要带些数据（如传感器读数）提交给服务器。 |
| `receivecb`                     | **比喻角色：幕后的大老板（也就是你）** 特工本身不懂情报的含义，他只负责搬运。这个变量存的是“你的电话号码”，等情报到了，特工就打这个电话叫你来处理。 |

#### 第二幕：前线实况直播（事件处理核心）

这是全剧最高潮的部分。特工出发了，`_http_event_handler` 就是特工随身携带的**无线电对讲机**，负责向基地汇报每一个步骤。

**注意**：特工的汇报是分段的，不是一次说完。

| **代码片段 / 逻辑**          | **现实世界的比喻与含义**                                     |
| ---------------------------- | ------------------------------------------------------------ |
| `static char *output_buffer` | **比喻道具：临时拼凑的收纳箱** ，<br>`static` 关键字意味着特工即使挂断了电话，下次再通话时，这个箱子还在，不会凭空消失。 |
| `HTTP_EVENT_ON_HEADER`       | **比喻动作：阅读快递清单** <br/>特工刚到仓库，先不搬货，而是看单子。**重点剧情**：当看到 `Content-Length` 时，特工知道了货有多大，于是立刻申请了一个对应大小的箱子（`malloc`）。 *注：这里特意用了 SPIRAM（外挂仓库），说明货可能很大，内部口袋装不下。* |
| `HTTP_EVENT_ON_DATA`         | **比喻动作：蚂蚁搬家** <br/>数据可能不是一次传完的。服务器发一点，特工就往箱子（`output_buffer`）里塞一点（`memcpy`），并用 `output_len` 记下已经装了多少。 |
| `HTTP_EVENT_ON_FINISH`       | **比喻动作：任务完成，交货撤退** <br/>所有数据搬运完毕。特工拨通了大老板的电话（`receivecb`），把箱子交出去。交完后，特工必须把箱子销毁（`free`），以免占用基地资源。 |
| `HTTP_EVENT_ERROR`           | **比喻动作：行动暴露，紧急止损**<br/> 如果中间出了岔子，也要记得把申请的箱子销毁（`free`），不能留垃圾。 |

#### 第三幕：发号施令（执行）

| **代码片段 / 函数**        | **现实世界的比喻与含义**                                     |
| -------------------------- | ------------------------------------------------------------ |
| `Dri_HttpClient_Request()` | **比喻动作：按下发射按钮** <br/>之前的都是准备，只有调用了这个函数，特工才真正跳上飞机，开始执行 `esp_http_client_perform`。 |

------

### 3. 核心逻辑精讲：为什么要有“内存申请”这一出戏？

这部分逻辑在 `HTTP_EVENT_ON_HEADER` 和 `HTTP_EVENT_ON_DATA` 中，是新手的**最大痛点**。

场景模拟：

想象你去超市买大米，但你出门时不知道要买多少。

1. **Header 阶段**：你看到了购物清单上写着“大米 50 斤”（`Content-Length`）。
2. **决策**：你看了看手里的塑料袋（栈内存），太小了破了。于是你立刻去服务台租了一辆小推车（`heap_caps_malloc`），而且是指名要那种“超大载重”的推车（`MALLOC_CAP_SPIRAM`）。
3. **Data 阶段**：服务员拿着铲子，一铲一铲地把米倒进你的推车里。你不能动，只能等着米装满。
4. **Finish 阶段**：米装满了，你把推车推给家人（回调函数）。家人把米倒进米缸后，你必须把推车还给超市（`free`）。如果你不还，下次再来买，超市可能就没车了（内存泄漏）。

**代码中的细节：**

C

```
// 只有看到 Content-Length 才知道申请多大空间
if( strcmp(evt->header_key,"Content-Length") == 0 ){
    uint16_t len =  atoi(evt->header_value); // 把字符串 "1024" 变成数字 1024
    output_buffer = (char*)heap_caps_malloc(len, MALLOC_CAP_SPIRAM); // 租车！
}
```

------

### 4. 总结

这段代码成功上演了一出**“动态接收 HTTP 数据”**的好戏：

1. **配置**：设定目标 URL 和证书。
2. **监听**：通过 Event Handler 监听连接状态。
3. **准备**：在 Header 阶段得知数据长度，动态申请内存（且使用了 PSRAM 外部内存，适合大数据）。
4. **接收**：分段接收数据拼接到 Buffer。
5. **交付**：接收完毕后，通过 Callback 回调给上层应用，并自动清理内存。

**在这个剧本里，最容易“NG（重拍）”的地方是内存管理：** 如果服务器没发 `Content-Length` 头，或者网络中途断开导致没走到 `ON_FINISH`，你的 `output_buffer` 可能就无法释放或者无法正确申请。现在的代码在 `ERROR` 和 `FINISH` 处都做了 `free`，这非常有经验，值得点赞！





![ESP32 httpclient系统流程图](assets/ESP32 httpclient系统流程图.png)